<!DOCTYPE html>
<html>
<head>
    <title>Test</title>
    <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.17/dist/interact.min.js"></script>

    <style>
        .letter {
            color: grey;
            font-size: 82px;
            font-weight: bold;
            width: fit-content;
            display: block;
        }
        .hidden {
            visibility: hidden;
        }
        .animate {
            transition: all .025s linear;
        }
        .draggable {
            touch-action: none;
            user-select: none;
            z-index: 100;
            position:absolute
        }
        .target {
            float: left;
        }
        #target-container {
            color: white;
            width: 100%;
            height:100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        body {
            height: 100%;
            overflow: hidden;
            user-select: none;
        }
</style>
</head>
<body>
    <div id="target-container"></div>
    <script>
        let wordList = ['Alaska','apple','aurora','baby','badger','ball','ballerina','banana','battery','beach','bear','beaver','beaver dam','bed','bee','beet','beluga','bicycle','bike','bird','blue','blueberry','boat','book','bowhead','bread','bridge','broccoli','cake','camping','canoe','carrot','castle','cat','caterpillar','cello','chair','chicken','chocolate','city','cliffs','clouds','coins','combine','computer','convertible','coral reef','cow','crab','crystal','cupcake','dam','danced','dear','desert','desk','dog','dolphin','drill','duck','dump truck','eagle','ear','earth','egg','elephant','etrog','excavator','eye','falcon','farm','ferry','fire engine','fire tower','fish','flower','fly','forest','fort','fox','frog','garbage truck','garden','gazelle','gecko','giraffe','glacier','golf','goose','gorilla','grape','greyhound','hammer','hands','hippo','horse','hot chocolate','house','humpback','husky','ice','ice cream','island','ISS','juice','kangaroo','king fisher','kite','kiwi','koi','lake','lava','lighthouse','lion','lulav','lynx','mars','merry go round','mesa','mezuzah','milk','mill','minke','minnow','monkey','moon','moose','motorcycle','mountain','mouse','mouth','muffin','mule','muskox','newspaper','northern lights','nose','oak','ocean','orca','otter','pepper','phone','plane','planet','pond','power line','puma','rain','rainbow','rainforest','raven','recorder','restaurant','right','river','road','rock','rocket','rookery','rose','rowboat','sailboat','salmon','sand','satellite','savanna','saxophone','scooter','sei','Shabbat','shells','ship','skid','skunk','sky','sled','snake','snow','snowflake','snowplow','snowshoes','soccer','solar panel','sperm whale','stars','strawberry','stream','sun','surfing','swan','table','tablet','taco','telephone','tennis','Texas','tidepool','tiger','toad','tools','torah','tractor','train','tree','treehouse','tressle','trombone','trout','trumpet','tuba','tulip','umbrella','violin','volcano','water','water tower','waves','wind','windmill','worm','wrench','yad','yak','zebra','zoo',];
        // wordList = ['a'];
        function setUpRandomWord() {
            let word = wordList[choose(0, wordList.length)];
            setUpWord(word);
        }

        function setUpWord(word) { 
            document.removeEventListener('pointerdown', setUpRandomWord);
            let targetContainer = $('#target-container');
            targetContainer.empty();
            for (i in word) {
                letter = word[i];
                let el = $(`<div class="letter"><div class="target letter hidden ${letter}-target">${letter}</div><div class="animate letter draggable ${letter}-draggable" data-x="0" data-y="0" data-ax="0" data-ay="0">${letter}</div></div>`)
                let item = targetContainer.append(el);
            }
            setRandomColor($('.draggable'))
            let draggables = $('.draggable');
            draggables.click(startExplosion)
        }

        function startExplosion(e) {
            // the word's been clicked!
            // explode all the letters to they can be put back together again.
            let word = [...document.querySelectorAll('.target')].reduce((w, el) => {return w + el.textContent;}, '')
            let utterance = new SpeechSynthesisUtterance(word);
            speechSynthesis.speak(utterance);
            let draggables = $('.draggable')
            let targets = $('.target')
            targets.removeClass('hidden');
            for (draggable of draggables) {
                startRandomAnimation(draggable, .05, .2, 5);
            }
            draggables.off('click');

            for (target of targets) {
                let letter = target.textContent
                interact(`.${letter}-target`)
                    .dropzone({
                        overlap: .5,
                        accept: `.${letter}-draggable`,
                        checker: function (
                            dragEvent,         // related dragmove or dragend
                            event,             // Touch, Pointer or Mouse Event
                            dropped,           // bool default checker result
                            dropzone,          // dropzone Interactable
                            dropzoneElement,   // dropzone element
                            draggable,         // draggable Interactable
                            draggableElement   // draggable element
                        ) {
                            // only allow drops into visible dropzone elements
                            return dropped && !dropzoneElement.classList.contains('hidden');
                        },
                        ondrop: function (event) {
                            let el = event.target;
                            el.classList.add('hidden');
                            interact(el).dropzone(false);
                            interact(event.relatedTarget).draggable(false);
                            if (!document.querySelectorAll('.target:not(.hidden)').length) {
                                completeWord();
                            }
                        },
                        ondragenter: function(event) {
                            let draggableEl = event.relatedTarget;
                            let targetEl  = event.target;
                            let dropRect         = interact.getElementRect(targetEl);
                            let dropCenter       = {
                                x: dropRect.left + dropRect.width  / 2,
                                y: dropRect.top  + dropRect.height / 2
                            };

                            event.draggable.draggable({
                                snap: {
                                    targets: [dropCenter]
                                }
                            });

                            // feedback the possibility of a drop
                            // targetEl.classList.add('can--catch');
                            // draggableEl.classList.add('drop--me');
                        },
                        ondragleave: function(event) {
                            let el  = event.relatedTarget;
                            event.draggable.draggable({
                                snap: {
                                    targets: [{x: parseInt(el.dataset.initx), y: parseInt(el.dataset.inity)}]
                                }
                            });
                        }
                    })
                    .on('dropactivate', function (event) {
                        event.target.classList.add('drop-activated')
                    })
            }

        }

        function completeWord() {
            // all letters have been put back together!
            // say the word and setup so next click starts a new word
            let word = [...document.querySelectorAll('.target')].reduce((w, el) => {return w + el.textContent;}, '')
            let utterance = new SpeechSynthesisUtterance(word);
            speechSynthesis.speak(utterance);
            document.addEventListener('pointerdown', setUpRandomWord);

        }
        function startRandomAnimation(el, min, max, a) {
            let containerEl = document.getElementById('target-container');
            let containerRect = containerEl.getBoundingClientRect();
            let xUnit = containerRect.width / 2;
            let yUnit = containerRect.height / 2;
            let spread = max - min;
            vx = xUnit * addMagnitude(choose(-spread, spread, 1/xUnit), min)
            vy = yUnit * addMagnitude(choose(-spread, spread, 1/yUnit), min)
            startAnimation(el, vx, vy, a);
        }

        function sign(a) {
            // return the sign (-1, 0, 1) of a
            return a/Math.abs(a) || 0;

        }

        function addMagnitude(a, b) {
            // add b to the absolute madgitude of a, while maintaining a's sign
            // ensure |a| + b does not go below 0
            // max((a/|a|)(|a| + b), 0)
            magnitude = Math.max((Math.abs(a) + b), 0)
            return sign(a) * magnitude;
        }

        function startAnimation(el, vx, vy, a) {
            // move the el element with an initial velocity of vx and vy
            // and an deceleration of a
            el.dataset.vx = vx;
            el.dataset.vy = vy;
            if (vx) {
                let ax = el.dataset.ax = Math.abs(a/Math.sqrt(1.0+Math.pow(vy/vx, 2)));
                el.dataset.ay = Math.abs(ax*vy/vx);
            } else {
                el.dataset.ay = a;
            }
            window.addEventListener("transitionend", animate);
            animate(el);
        }

        function animate(el) {
            if (el.target) {
                el = el.target;
            }
            targetContainer = $('#target-container');
            let rect = el.getBoundingClientRect();
            let vx = parseFloat(el.dataset.vx);
            vx = manageCollision(vx, rect.width, rect.left, targetContainer.width());
            let vy = parseFloat(el.dataset.vy);
            vy = manageCollision(vy, rect.height, rect.top, targetContainer.height());
            let ax = parseFloat(el.dataset.ax);
            let ay = parseFloat(el.dataset.ay);
            if (Math.round(vx) || Math.round(vy)) {
                translate(el, vx, vy);
                el.dataset.vx = addMagnitude(vx, -ax);
                el.dataset.vy = addMagnitude(vy, -ay);
            } else {
                el.dataset.vx = 0;
                el.dataset.vy = 0;
                finishAnimation(el);
                return;
            }
            
        }
        
        function manageCollision(v, size, pos, max) {
            let newPos = pos + v;
            if (newPos > (max - size) || newPos < 0) {
                return -v;
            } else {
                return v;
            }
        }

        function finishAnimation(el) {
            console.log('finish animating', el.textContent);
            el.removeEventListener("transitionend", animate);
            let rect = el.getBoundingClientRect();
            let initx = el.dataset.initx = rect.left + rect.width  / 2;
            let inity = el.dataset.inity = rect.top + rect.height / 2
            el.classList.remove('animate');
            el.addEventListener('pointerdown', function(event) {
                let utterance = new SpeechSynthesisUtterance(event.target.textContent);
                speechSynthesis.speak(utterance);
            })
            interact(el).draggable({
                listeners: {
                    start(event) {
                        event.target.classList.add('dragging');
                    },
                    move(event) {
                        translate(event.target, event.dx, event.dy);
                    },
                    end(event) {
                        event.target.classList.remove('dragging');

                    }
                },
                snap: {
                    targets: [{x: initx, y: inity}],
                    range: Infinity,
                    relativePoints: [ { x: 0.5, y: 0.5 } ],
                    endOnly: true
                }
            });
        }

        function translate(el, dx, dy) {
            // translate el by 
            let x = parseFloat(el.dataset.x)
            let y = parseFloat(el.dataset.y)
            x += dx;
            y += dy;

            el.style.transform =
                `translate(${Math.round(x)}px, ${Math.round(y)}px)`
            
            el.dataset.x = x;
            el.dataset.y = y;
        }

        function choose(min, max, step) {
            // choose an integer between min (inclusive) and max (exclusive)
            // if step is given, only return integers divisible by step
            step = step || 1;
            return min + (Math.floor((Math.random() * (max - min) / step)) * step);
        }

        function getRandomColor() {
            // Get a Random Color defined by hsl. 
            // hsl allows us to eliminate the preponderance of "muddy" colors you get when choosing in RGB
            // hue: 20 degree increments
            // saturation: 100%
            // lightness: between 40% and 80%
            let h = choose(0, 360, 20)
            let l = choose(40, 100, 10)
            let color = 'hsl(' + h + ', 100%, ' + l + '%)'
            return color;
        }

        function setRandomColor(els) {
            // set each element in els to a different random color.
            for (el of els) {
                $(el).css("color", getRandomColor());
            }
        }
        
        // kick everything off!
        setUpRandomWord();
    </script>

</body>
</html>